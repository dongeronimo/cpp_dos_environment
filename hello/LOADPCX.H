// http://www.fysnet.net/pcxfile.htm
// https://gist.github.com/warmwaffles/64d1a8c677997fc8c3df4fa7364d33cc
// https://www.fileformat.info/format/pcx/egff.htm

#ifndef __loadpcx_h
#define __loadpcx_h
#include "LOGGER.H"
#include <stdio.h> 
#include "IMAGE.H"
#include <stdlib.h>
#include <string.h>
#include <cassert>

typedef uint16_t WORD;
typedef uint8_t BYTE;


typedef struct _PcxHeader
{
    BYTE  Identifier;        /* PCX Id Number (Always 0x0A) */
    BYTE  Version;           /* Version Number */
    BYTE  Encoding;          /* Encoding Format */
    BYTE  BitsPerPixel;      /* Bits per Pixel */
    WORD  XStart;            /* Left of image */
    WORD  YStart;            /* Top of Image */
    WORD  XEnd;              /* Right of Image*/
    WORD  YEnd;              /* Bottom of image */
    WORD  HorzRes;           /* Horizontal Resolution */
    WORD  VertRes;           /* Vertical Resolution */
    BYTE  Palette[48];       /* 16-Color EGA Palette */
    BYTE  Reserved1;         /* Reserved (Always 0) */
    BYTE  NumBitPlanes;      /* Number of Bit Planes */
    WORD  BytesPerLine;      /* Bytes per Scan-line */
    WORD  PaletteType;       /* Palette Type */
    WORD  HorzScreenSize;    /* Horizontal Screen Size */
    WORD  VertScreenSize;    /* Vertical Screen Size */
    BYTE  Reserved2[54];     /* Reserved (Always 0) */
} PCXHEAD;

struct Color {
    uint8_t r, g, b;
};
#define LOAD_PCX_SUCCESS 0
#define LOAD_PCX_INVALID_FORMAT 1
#define LOAD_PCX_INVALID_ENCODING 2
#define LOAD_PCX_INVALID_VERSION 3
#define LOAD_PCX_INVALID_BITS_PER_PIXEL 5
#define LOAD_PCX_INVALID_BIT_PLANES 7
#define LOAD_PCX_NO_PALETTE 11
/// @brief Loads a pcx file into an image struct. It assumes that the encoding
/// is RLE, that the version is last pc paintbrush version (5), that there are
/// 8 bits per pixel and that there is only one bit plane. If some of these assumptions
/// are not met it'll return with an error code.
/// The result is written at the image reference parameter. The reference must not be null,
/// this function will fill it. The reference will be responsible for the allocated memory,
/// not this function.
/// The palette is written at the palette pointer if it isn't null. The palette may or may not
/// have valid data. If your file was generated by gimp it
/// will probably have a valid palette. If there is no valid palette the function will return
/// LOAD_PCX_NO_PALETTE but the image data will be present in img.
///
/// I EXPECT THAT THE IMAGE IS A MULTIPLE OF 8.
/// @param image the path to the image
/// @param img must not be null, data will be filled by LoadPCX
/// @param palette must be a 256 color array, alredy allocated
/// @return LOAD_PCX_SUCCESS if success, LOAD_PCX_NO_PALETTE if success but no palette, the other LOAD_PCX_* in any other case
static uint32_t LoadPCX(const char* image, Image& img, Color* palette) {
    uint32_t headerStructSize = sizeof(PCXHEAD);
    //It MUST be 128. Due to alignment issues it can be bigger or smaller, 
    // If so, i have to add/remove padding
    assert(headerStructSize == 128);
    FILE* f = NULL;
    f = fopen(image, "rb");
    PCXHEAD header;
    memset(&header, 0, sizeof(PCXHEAD));
    fread(&header, sizeof(PCXHEAD), 1, f);
    uint32_t posAfterReadingHeader = ftell(f);
    // Log("pos after read = %d\n", posAfterReadingHeader);
    //I MUST be at 128 after reading the header to read the scanlines.
    assert(posAfterReadingHeader == 128);
    //validações
    if (header.Identifier != 0x0a){
        fclose(f);  
        return LOAD_PCX_INVALID_FORMAT;
    }
    if (header.Encoding != 1){
        fclose(f);  
        return LOAD_PCX_INVALID_ENCODING;
    }
    if (header.Version != 5){
        fclose(f);  
        return LOAD_PCX_INVALID_VERSION;
    }
    if (header.BitsPerPixel != 8){
        fclose(f);  
        return LOAD_PCX_INVALID_BITS_PER_PIXEL;
    }
    if (header.NumBitPlanes != 1){
        fclose(f);  
        return LOAD_PCX_INVALID_BIT_PLANES;
    }


    uint16_t ImageWidth = header.XEnd - header.XStart + 1;
    uint16_t ImageHeight = header.YEnd - header.YStart + 1;
    uint16_t ScanlineLength = header.NumBitPlanes * header.BytesPerLine;
    // uint16_t LinePaddingSize = ((header.BytesPerLine * header.NumBitPlanes) *
    //     (8 / header.BitsPerPixel)) - ((header.XEnd - header.XStart) + 1);

    uint8_t* ScanlineBuffer = new uint8_t[ScanlineLength];
    memset(ScanlineBuffer, 0xFF, ScanlineLength);
    uint32_t index = 0;
    uint8_t runcount = 0;
    uint8_t runvalue = 0;
    uint32_t scanlineCursor = 0;
    //prepara a struct
    img.Width = ImageWidth;
    img.Height = ImageHeight;
    img.Scanlines = new uint8_t * [ImageHeight];
    for (int i = 0; i < ImageHeight; i++) {
        img.Scanlines[i] = new uint8_t[ScanlineLength];
    }
    //lê a scanline
    while (index < ImageHeight * ImageWidth) {
        scanlineCursor = 0;
        runcount = 0;
        runvalue = 0;
        while(scanlineCursor < ScanlineLength) {
            //lê o byte e avalia se é indicador de uma run-length de pixels
            //ou se é um pixel isolado
            uint8_t byte = getc(f);
            if ((byte & 0xC0) == 0xC0) {
                runcount = byte & 0x3F; //pega a runcount
                runvalue = getc(f); //proximo byte é o valor dos pixels dessa runcount
            }
            else {
                runcount = 1;
                runvalue = byte;
            }
            //aplica a run-length à scanline.
            memset(ScanlineBuffer + scanlineCursor, runvalue, runcount);
            scanlineCursor += runcount;//incrementa o cursor
        }
        memcpy(img.Scanlines[index / ScanlineLength], ScanlineBuffer, ScanlineLength);
        index += ScanlineLength;
    }
    delete[] ScanlineBuffer;
    uint16_t code =  LOAD_PCX_SUCCESS;
    if(palette != NULL){
        uint8_t paletteMark;
        fread(&paletteMark, sizeof(uint8_t), 1, f);
        if (paletteMark == 12) { //tem paleta, lê o resto do arquivo
            fread(palette, sizeof(palette) * 256, 1, f); // to assumindo q a paleta já está alocada
        }else{
            code = LOAD_PCX_NO_PALETTE;
        }
    }
    fclose(f);    
    return code;
}

static uint16_t LoadFromFile(const char* filename, Image& bitmap, Color* palette){
    uint16_t result = LoadPCX(filename, bitmap, palette);

    // switch (result)
    // {
    // case LOAD_PCX_INVALID_FORMAT:
    //     Log("Error: invalid format\n");
    //     return result;
    // case LOAD_PCX_INVALID_ENCODING:
    //     Log("Error: invalid encoding\n");
    //     return result;
    // case LOAD_PCX_INVALID_VERSION:
    //     Log("Error: invalid version\n");
    //     return result;
    // case LOAD_PCX_INVALID_BITS_PER_PIXEL:
    //     Log("Error: invalid bits per pixel\n");
    //     return result;
    // case LOAD_PCX_INVALID_BIT_PLANES:
    //     Log("Error: invalid bitplanes\n");
    //     return result;
    // case LOAD_PCX_NO_PALETTE:
    //     Log("Warn: No palette\n");
    //     break;
    // }
    Log("---%s---\n", filename);
    for (int y = 0; y < bitmap.Height; y++) {
        for (int x = 0; x < bitmap.Width; x++) {
            Log(log_bit_mask, bitmap.Scanlines[y][x]);
        }
        Log("\n");
    }
    Log("---Palette---\n");
    for (int i = 0; i < 256; i++) {
        Log("ID:%#04X R:%d G:%d B:%d \n",i, palette[i].r, palette[i].g, palette[i].b);
    }

    return result;
}
#endif